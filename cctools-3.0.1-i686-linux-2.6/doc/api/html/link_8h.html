<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>cctools: link.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_7afb20efd3222486f618d55c1155b0c9.html">dttools</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_6c8716ef915dcad8c2de740107ec87f7.html">src</a></div>
<h1>link.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
A high level TCP connection library. 
<p>
A <b>link</b> is a TCP connection to a process on another machine. This module works at a higher level of abstraction than the socket library, with an easier-to-use API and explicit support for timeouts. <p>
Timeouts are specified using an absolute stoptime. For example, if you want a connection to be attempted for sixty seconds, specify <code>time(0)+60</code>. The operation will be tried and retried until that absolute limit, giving the caller much greater control over program behavior. <p>
Note that this library manipulates IP addresses in the form of strings. To convert a hostname into a string IP address, call <a class="el" href="domain__name__cache_8h.html#4bcc4c869a2836fe2295d758391e6d09">domain_name_cache_lookup</a>. For example, here is how to make a simple HTTP request: <pre>
struct link *link;
time_t stoptime = time(0)+300;
char addr[LINK_ADDRESS_MAX];
int result;</pre><p>
<pre>const char *request = "GET / HTTP/1.0\n\n";</pre><p>
<pre>result = domain_name_lookup_cache("www.google.com",addr);
if(result!=0) fatal("could not lookup name");</pre><p>
<pre>link = link_connect(addr,80,stoptime);
if(!link) fatal("could not connect");</pre><p>
<pre>result = link_write(link,request,strlen(request),stoptime);
if(result&lt;0) fatal("could not send request");</pre><p>
<pre>link_stream_to_file(link,stdout,1000000,stoptime);
link_close(link);
</pre> 
<p>
<code>#include &quot;int_sizes.h&quot;</code><br>
<code>#include &lt;time.h&gt;</code><br>
<code>#include &lt;limits.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;sys/types.h&gt;</code><br>

<p>
<a href="link_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>link_info</b></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#ee1eac35b3b0cc6899cdc3ee0af78f4e">LINK_ADDRESS_MAX</a>&nbsp;&nbsp;&nbsp;48</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of characters in the text representation of a link address.  <a href="#ee1eac35b3b0cc6899cdc3ee0af78f4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#a76c893b5d09fa568b93572e96e14f12">LINK_PORT_ANY</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value to usewhen any listen port is acceptable.  <a href="#a76c893b5d09fa568b93572e96e14f12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#e45ac49c99cde97c10671966d8ea1ecb">LINK_FOREVER</a>&nbsp;&nbsp;&nbsp;((time_t)INT_MAX)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stoptime to give when you wish to wait forever.  <a href="#e45ac49c99cde97c10671966d8ea1ecb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">link *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#320c480103b59a4048d22cdc5329004c">link_connect</a> (const char *addr, int port, time_t stoptime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to a remote host.  <a href="#320c480103b59a4048d22cdc5329004c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">link *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#9d76a3da9666eb0788ee1a5887d0627d">link_serve</a> (int port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare to accept connections.  <a href="#9d76a3da9666eb0788ee1a5887d0627d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">link *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#cd32b7ea948942d215442cc21ed04565">link_serve_address</a> (const char *addr, int port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare to accept connections on one network interface.  <a href="#cd32b7ea948942d215442cc21ed04565"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">link *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#8908af96a78489539f87f902b6f81500">link_accept</a> (struct link *master, time_t stoptime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept one connection.  <a href="#8908af96a78489539f87f902b6f81500"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#f9c7e19b655fcca15606a608c4e8e6a4">link_read</a> (struct link *link, char *data, int length, time_t stoptime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data from a connection.  <a href="#f9c7e19b655fcca15606a608c4e8e6a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#7068a72deb99c8d28a4418892b5288f8">link_read_avail</a> (struct link *link, char *data, int length, time_t stoptime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read available data from a connection.  <a href="#7068a72deb99c8d28a4418892b5288f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#50751b2a3f1ffb811ee6b0fc2b97b6ac">link_write</a> (struct link *link, const char *data, int length, time_t stoptime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write data to a connection.  <a href="#50751b2a3f1ffb811ee6b0fc2b97b6ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#88872a9b3d0490d2f690e34486786ac5">link_usleep</a> (struct link *link, int usec, int reading, int writing)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block until a link is readable or writable.  <a href="#88872a9b3d0490d2f690e34486786ac5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#78703bd2617ee9ad8241a827d073845a">link_close</a> (struct link *link)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a connection.  <a href="#78703bd2617ee9ad8241a827d073845a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#7045ffa5914a397e65ff2fe6383cf5fa">link_window_set</a> (int send_window, int recv_window)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the TCP window size to be used for all links.  <a href="#7045ffa5914a397e65ff2fe6383cf5fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#7037bdee21acda4661afa54614fc917b">link_window_get</a> (struct link *link, int *send_window, int *recv_window)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the TCP window size actually allocated for this link.  <a href="#7037bdee21acda4661afa54614fc917b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#943defddbb6a21a4b50c2fcb10693e10">link_readline</a> (struct link *link, char *line, int length, time_t stoptime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a line of text from a link.  <a href="#943defddbb6a21a4b50c2fcb10693e10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#97dac33660a5fb7333807bb90812a641">link_fd</a> (struct link *link)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the underlying file descriptor of a link.  <a href="#97dac33660a5fb7333807bb90812a641"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#cc347b042e023a279eec60de1395e9ae">link_address_local</a> (struct link *link, char *addr, int *port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the local address of the link in text format.  <a href="#cc347b042e023a279eec60de1395e9ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="link_8h.html#b692af1dacd63beb4d333fb8b5d117dc">link_address_remote</a> (struct link *link, char *addr, int *port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the remote address of the link in text format.  <a href="#b692af1dacd63beb4d333fb8b5d117dc"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="ee1eac35b3b0cc6899cdc3ee0af78f4e"></a><!-- doxytag: member="link.h::LINK_ADDRESS_MAX" ref="ee1eac35b3b0cc6899cdc3ee0af78f4e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LINK_ADDRESS_MAX&nbsp;&nbsp;&nbsp;48          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum number of characters in the text representation of a link address. 
<p>
This must be large enough to accomodate ipv6 in the future. 
</div>
</div><p>
<a class="anchor" name="a76c893b5d09fa568b93572e96e14f12"></a><!-- doxytag: member="link.h::LINK_PORT_ANY" ref="a76c893b5d09fa568b93572e96e14f12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LINK_PORT_ANY&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Value to usewhen any listen port is acceptable. 
<p>

</div>
</div><p>
<a class="anchor" name="e45ac49c99cde97c10671966d8ea1ecb"></a><!-- doxytag: member="link.h::LINK_FOREVER" ref="e45ac49c99cde97c10671966d8ea1ecb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LINK_FOREVER&nbsp;&nbsp;&nbsp;((time_t)INT_MAX)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stoptime to give when you wish to wait forever. 
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="320c480103b59a4048d22cdc5329004c"></a><!-- doxytag: member="link.h::link_connect" ref="320c480103b59a4048d22cdc5329004c" args="(const char *addr, int port, time_t stoptime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct link* link_connect           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to a remote host. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>IP address of server in string form. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port of server. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>Absolute time at which to abort. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, returns a pointer to a link object. On failure, returns a null pointer with errno set appropriately. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9d76a3da9666eb0788ee1a5887d0627d"></a><!-- doxytag: member="link.h::link_serve" ref="9d76a3da9666eb0788ee1a5887d0627d" args="(int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct link* link_serve           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepare to accept connections. 
<p>
<a class="el" href="link_8h.html#9d76a3da9666eb0788ee1a5887d0627d">link_serve</a> will accept connections on any network interface, which is usually what you want. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port number to listen on. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>link A server endpoint that can be passed to <a class="el" href="link_8h.html#8908af96a78489539f87f902b6f81500">link_accept</a>, or null on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd32b7ea948942d215442cc21ed04565"></a><!-- doxytag: member="link.h::link_serve_address" ref="cd32b7ea948942d215442cc21ed04565" args="(const char *addr, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct link* link_serve_address           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepare to accept connections on one network interface. 
<p>
Functions like <a class="el" href="link_8h.html#9d76a3da9666eb0788ee1a5887d0627d">link_serve</a>, except that the server will only be visible on the given network interface. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>IP address of the network interface. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port number to listen on. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>link A server endpoint that can be passed to <a class="el" href="link_8h.html#8908af96a78489539f87f902b6f81500">link_accept</a>, or null on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8908af96a78489539f87f902b6f81500"></a><!-- doxytag: member="link.h::link_accept" ref="8908af96a78489539f87f902b6f81500" args="(struct link *master, time_t stoptime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct link* link_accept           </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>master</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accept one connection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>master</em>&nbsp;</td><td>A link returned from <a class="el" href="link_8h.html#9d76a3da9666eb0788ee1a5887d0627d">link_serve</a> or <a class="el" href="link_8h.html#cd32b7ea948942d215442cc21ed04565">link_serve_address</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The time at which to abort. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>link A connection to a client, or null on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f9c7e19b655fcca15606a608c4e8e6a4"></a><!-- doxytag: member="link.h::link_read" ref="f9c7e19b655fcca15606a608c4e8e6a4" args="(struct link *link, char *data, int length, time_t stoptime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_read           </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data from a connection. 
<p>
This call will block until the given number of bytes have been read, or the connection is dropped. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link from which to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A buffer to hold the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The time at which to abort. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes actually read, or zero if the connection is closed, or less than zero on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7068a72deb99c8d28a4418892b5288f8"></a><!-- doxytag: member="link.h::link_read_avail" ref="7068a72deb99c8d28a4418892b5288f8" args="(struct link *link, char *data, int length, time_t stoptime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_read_avail           </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read available data from a connection. 
<p>
This call will read whatever data is immediately available, and then return without blocking. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link from which to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A buffer to hold the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The time at which to abort. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes actually read, or zero if the connection is closed, or less than zero on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="50751b2a3f1ffb811ee6b0fc2b97b6ac"></a><!-- doxytag: member="link.h::link_write" ref="50751b2a3f1ffb811ee6b0fc2b97b6ac" args="(struct link *link, const char *data, int length, time_t stoptime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_write           </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write data to a connection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The number of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The time at which to abort. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes actually written, or less than zero on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="88872a9b3d0490d2f690e34486786ac5"></a><!-- doxytag: member="link.h::link_usleep" ref="88872a9b3d0490d2f690e34486786ac5" args="(struct link *link, int usec, int reading, int writing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_usleep           </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>usec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>writing</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Block until a link is readable or writable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to wait on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>usec</em>&nbsp;</td><td>The maximum number of microseconds to wait. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reading</em>&nbsp;</td><td>Wait for the link to become readable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writing</em>&nbsp;</td><td>Wait for the link to become writable. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>One if the link becomes readable or writable before the timeout expires, zero otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="78703bd2617ee9ad8241a827d073845a"></a><!-- doxytag: member="link.h::link_close" ref="78703bd2617ee9ad8241a827d073845a" args="(struct link *link)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void link_close           </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close a connection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The connection to close. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7045ffa5914a397e65ff2fe6383cf5fa"></a><!-- doxytag: member="link.h::link_window_set" ref="7045ffa5914a397e65ff2fe6383cf5fa" args="(int send_window, int recv_window)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void link_window_set           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>send_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>recv_window</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the TCP window size to be used for all links. 
<p>
Takes effect on future calls to <a class="el" href="link_8h.html#320c480103b59a4048d22cdc5329004c">link_connect</a> or <a class="el" href="link_8h.html#8908af96a78489539f87f902b6f81500">link_accept</a>. Default value is set by the system or by the environment variable TCP_WINDOW_SIZE. Note that the operating system may place limits on the buffer sizes actually allocated. Use <a class="el" href="link_8h.html#7037bdee21acda4661afa54614fc917b">link_window_get</a> to retrieve the buffer actually allocated for a given link. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>send_window</em>&nbsp;</td><td>The size of the send window, in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recv_window</em>&nbsp;</td><td>The size of the recv window, in bytes. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7037bdee21acda4661afa54614fc917b"></a><!-- doxytag: member="link.h::link_window_get" ref="7037bdee21acda4661afa54614fc917b" args="(struct link *link, int *send_window, int *recv_window)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void link_window_get           </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>send_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>recv_window</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the TCP window size actually allocated for this link. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to examine. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>send_window</em>&nbsp;</td><td>A pointer where to store the send window. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recv_window</em>&nbsp;</td><td>A pointer where to store the receive window. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="943defddbb6a21a4b50c2fcb10693e10"></a><!-- doxytag: member="link.h::link_readline" ref="943defddbb6a21a4b50c2fcb10693e10" args="(struct link *link, char *line, int length, time_t stoptime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_readline           </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&nbsp;</td>
          <td class="paramname"> <em>stoptime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a line of text from a link. 
<p>
Reads a line of text, up to and including a newline, interpreted as either LF or CR followed by LF. The line actually returned is null terminated and does not contain the newline indicator. An internal buffer is used so that readline can usually complete with zero or one system calls. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>A pointer to a buffer to fill with data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the buffer in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stoptime</em>&nbsp;</td><td>The absolute time at which to abort. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>If greater than zero, a line was read, and the return value indicates the length in bytes. If equal to zero, end of stream was reached. If less than zero, an error occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="97dac33660a5fb7333807bb90812a641"></a><!-- doxytag: member="link.h::link_fd" ref="97dac33660a5fb7333807bb90812a641" args="(struct link *link)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_fd           </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the underlying file descriptor of a link. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to examine. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The integer file descriptor of the link. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cc347b042e023a279eec60de1395e9ae"></a><!-- doxytag: member="link.h::link_address_local" ref="cc347b042e023a279eec60de1395e9ae" args="(struct link *link, char *addr, int *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_address_local           </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the local address of the link in text format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to examine. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Pointer to a string of at least <a class="el" href="link_8h.html#ee1eac35b3b0cc6899cdc3ee0af78f4e">LINK_ADDRESS_MAX</a> bytes, which will be filled with a text representation of the local IP address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Pointer to an integer, which will be filled with the TCP port number. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b692af1dacd63beb4d333fb8b5d117dc"></a><!-- doxytag: member="link.h::link_address_remote" ref="b692af1dacd63beb4d333fb8b5d117dc" args="(struct link *link, char *addr, int *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int link_address_remote           </td>
          <td>(</td>
          <td class="paramtype">struct link *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the remote address of the link in text format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link to examine. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>Pointer to a string of at least <a class="el" href="link_8h.html#ee1eac35b3b0cc6899cdc3ee0af78f4e">LINK_ADDRESS_MAX</a> bytes, which will be filled with a text representation of the remote IP address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Pointer to an integer, which will be filled with the TCP port number. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Mon Mar 29 15:56:19 2010 for cctools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
